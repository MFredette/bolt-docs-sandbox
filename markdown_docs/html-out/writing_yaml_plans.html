<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2019"><meta name="DC.rights.owner" content="(C) Copyright 2019"><meta name="DC.type" content="topic"><meta name="DC.creator" content="Melissa Amos <melissa.amos@puppet.com\&gt;"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="writing-plans-in-yaml"><link rel="stylesheet" type="text/css" href="commonltr.css"><title>Writing plans in YAML</title></head><body id="writing-plans-in-yaml"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">Writing plans in YAML</h1><div class="body"><p class="p">YAML plans run a list of steps in order, which allows you to define simple workflows. Steps can contain embedded Puppet code expressions to add logic where necessary.</p><p class="p"><strong class="ph b">Note:</strong> YAML plans are an experimental feature and might experience breaking changes in future minor \(y\) releases.</p><p class="p"><strong class="ph b">Parent topic:</strong><a class="xref" href="writing_tasks_and_plans.html">Tasks and plans</a></p></div><article class="topic nested1" aria-labelledby="ariaid-title2" id="naming-plans"><h2 class="title topictitle2" id="ariaid-title2">Naming plans</h2><div class="body"><p class="p">Plan names are named based on the filename of the plan, the name of the module containing the plan, and the path to the plan within the module.</p><p class="p">Place plan files in your module's <code class="ph codeph">./plans</code> directory, using these file extensions:</p><ul class="ul"><li class="li"><p class="p">Puppet plans — <code class="ph codeph">.pp</code></p></li><li class="li"><p class="p">YAML plans — <code class="ph codeph">.yaml</code>, not <code class="ph codeph">.yml</code></p></li></ul><p class="p">Plan names are composed of two or more name segments, indicating:</p><ul class="ul"><li class="li"><p class="p">The name of the module the plan is located in.</p></li><li class="li"><p class="p">The name of the plan file, without the extension.</p></li><li class="li"><p class="p">The path within the module, if the plan is in a subdirectory of <code class="ph codeph">./plans</code>.</p></li></ul><p class="p">For example, given a module called <code class="ph codeph">mymodule</code> with a plan defined in <code class="ph codeph">./mymodule/plans/myplan.pp</code>, the plan name is <code class="ph codeph">mymodule::myplan</code>. A plan defined in <code class="ph codeph">./mymodule/plans/service/myplan.pp</code>would be <code class="ph codeph">mymodule::service::myplan</code>. This name is how you refer to the plan when you run commands.</p><p class="p">The plan filename <code class="ph codeph">init</code> is special: the plan it defines is referenced using the module name only. For example, in a module called <code class="ph codeph">mymodule</code>, the plan defined in <code class="ph codeph">init.pp</code> is the <code class="ph codeph">mymodule</code> plan.</p><p class="p">Avoid giving plans the same names as constructs in the Puppet language. Although plans do not share their namespace with other language constructs, giving plans these names makes your code difficult to read.</p><p class="p">Each plan name segment must begin with a lowercase letter and:</p><ul class="ul"><li class="li"><p class="p">May include lowercase letters.</p></li><li class="li"><p class="p">May include digits.</p></li><li class="li"><p class="p">May include underscores.</p></li><li class="li"><p class="p">Must not be a <a class="xref" href="https://docs.puppet.com/puppet/5.3/lang_reserved.html" target="_blank">reserved word</a>.</p></li><li class="li"><p class="p">Must not have the same name as any Puppet data types.</p></li><li class="li"><p class="p">Namespace segments must match the following regular expression <code class="ph codeph">\A[a-z][a-z0-9_]*\Z</code></p></li></ul></div></article><article class="topic nested1" aria-labelledby="ariaid-title3" id="plan-structure"><h2 class="title topictitle2" id="ariaid-title3">Plan structure</h2><div class="body"><p class="p">YAML plans contain a list of steps with optional parameters and results.</p><p class="p">YAML maps accept these keys:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">steps</code>: The list of steps to perform</p></li><li class="li"><p class="p"><code class="ph codeph">parameters</code>: \(Optional\) The parameters accepted by the plan</p></li><li class="li"><p class="p"><code class="ph codeph">return</code>: \(Optional\) The value to return from the plan</p></li></ul></div><article class="topic nested2" aria-labelledby="ariaid-title4" id="steps-key"><h3 class="title topictitle3" id="ariaid-title4">Steps key</h3><div class="body"><p class="p">The <code class="ph codeph">steps</code> key is an array of step objects, each of which corresponds to a specific action to take.</p><p class="p">When the plan runs, each step is executed in order. If a step fails, the plan halts execution and raises an error containing the result of the step that failed.</p><p class="p">Steps use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">name</code>: A unique name that can be used to refer to the result of the step later</p></li><li class="li"><p class="p"><code class="ph codeph">description</code>: \(Optional\) An explanation of what the step is doing.</p></li></ul><p class="p">Other available keys depend on the type of step.</p></div><article class="topic nested3" aria-labelledby="ariaid-title5" id="command-step"><h4 class="title topictitle4" id="ariaid-title5">Command step</h4><div class="body"><p class="p">Use a <code class="ph codeph">command</code> step to run a single command on a list of targets and save the results, containing stdout, stderr, and exit code.</p><p class="p">The step fails if the exit code of any command is non-zero.</p><p class="p">Command steps use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">command</code>: The command to run</p></li><li class="li"><p class="p"><code class="ph codeph">target</code>: A target or list of targets to run the command on</p></li></ul><p class="p">For example:</p><pre class="pre codeblock"><code>steps:
  - command: hostname -f
    target:
      - web1.example.com
      - web2.example.com
      - web3.example.com
    description: "Get the webserver hostnames"</code></pre></div></article><article class="topic nested3" aria-labelledby="ariaid-title6" id="task-step"><h4 class="title topictitle4" id="ariaid-title6">Task step</h4><div class="body"><p class="p">Use a <code class="ph codeph">task</code> step to run a Bolt task on a list of targets and save the results.</p><p class="p">Task steps use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">task</code>: The task to run</p></li><li class="li"><p class="p"><code class="ph codeph">target</code>: A target or list of targets to run the task on</p></li><li class="li"><p class="p"><code class="ph codeph">parameters</code>: \(Optional\) A map of parameter values to pass to the task</p></li></ul><p class="p">For example:</p><pre class="pre codeblock"><code>steps:
  - task: package
    target:
      - web1.example.com
      - web2.example.com
      - web3.example.com
    description: "Check the version of the openssl package on the webservers"
    parameters:
      action: status
      name: openssl</code></pre></div></article><article class="topic nested3" aria-labelledby="ariaid-title7" id="script-step"><h4 class="title topictitle4" id="ariaid-title7">Script step</h4><div class="body"><p class="p">Use a <code class="ph codeph">script</code> step to run a script on a list of targets and save the results.</p><p class="p">The script must be in the <code class="ph codeph">files/</code> directory of a module. The name of the script must be specified as <code class="ph codeph">&lt;modulename&gt;/path/to/script</code>, omitting the <code class="ph codeph">files</code> directory from the path.</p><p class="p">Script steps use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">script</code>: The script to run</p></li><li class="li"><p class="p"><code class="ph codeph">target</code>: A target or list of targets to run the script on</p></li><li class="li"><p class="p"><code class="ph codeph">arguments</code>: \(Optional\) An array of command-line arguments to pass to the script</p></li></ul><p class="p">For example:</p><pre class="pre codeblock"><code>steps:
  - script: mymodule/check_server.sh
    target:
      - web1.example.com
      - web2.example.com
      - web3.example.com
    description: "Run mymodule/files/check_server.sh on the webservers"
    arguments:
      - "/index.html"
      - 60</code></pre></div></article><article class="topic nested3" aria-labelledby="ariaid-title8" id="file-upload-step"><h4 class="title topictitle4" id="ariaid-title8">File upload step</h4><div class="body"><p class="p">Use a file upload step to upload a file to a specific location on a list of targets.</p><p class="p">The file to upload must be in the <code class="ph codeph">files/</code> directory of a Puppet module. The source for the file must be specified as <code class="ph codeph">&lt;modulename&gt;/path/to/file</code>, omitting the <code class="ph codeph">files</code> directory from the path.</p><p class="p">File upload steps use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">source</code>: The location of the file to be uploaded</p></li><li class="li"><p class="p"><code class="ph codeph">destination</code>: The location where the file should be uploaded to</p></li></ul><p class="p">For example:</p><pre class="pre codeblock"><code>steps:
  - source: mymodule/motd.txt
    destination: /etc/motd
    target:
      - web1.example.com
      - web2.example.com
      - web3.example.com
    description: "Upload motd to the webservers"</code></pre></div></article><article class="topic nested3" aria-labelledby="ariaid-title9" id="plan-step"><h4 class="title topictitle4" id="ariaid-title9">Plan step</h4><div class="body"><p class="p">Use a <code class="ph codeph">plan</code> step to run another plan and save its result.</p><p class="p">Plan steps use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">plan</code>: The name of the plan to run</p></li><li class="li"><p class="p"><code class="ph codeph">parameters</code>: \(Optional\) A map of parameter values to pass to the plan</p></li></ul><p class="p">For example:</p><pre class="pre codeblock"><code>steps:
  - plan: facts
    description: "Gather facts for the webservers using the built-in facts plan"
    parameters:
      nodes:
        - web1.example.com
        - web2.example.com
        - web3.example.com</code></pre></div></article><article class="topic nested3" aria-labelledby="ariaid-title10" id="resources-step"><h4 class="title topictitle4" id="ariaid-title10">Resources step</h4><div class="body"><p class="p">Use a <code class="ph codeph">resources</code> step to apply a list of Puppet resources. A resource defines the desired state for part of a target. Bolt ensures each resource is in its desired state. Like the steps in a <code class="ph codeph">plan</code>, if any resource in the list fails, the rest are skipped.</p><p class="p">Resources steps use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">resouces</code>: An array of resources to apply</p></li><li class="li"><p class="p"><code class="ph codeph">target</code>: A target or list of targets to apply the resources on</p></li></ul><p class="p">Each resource is a YAML map with a type and title, and optionally a <code class="ph codeph">parameters</code> key. The resource type and title can either be specified separately with the <code class="ph codeph">type</code> and <code class="ph codeph">title</code> keys, or can be specified in a single line by using the type name as a key with the title as its value.</p><p class="p">For example:</p><pre class="pre codeblock"><code>steps:
  - resources:
    # This resource is type 'package' and title 'nginx'
    - package: nginx
      parameters:
        ensure: latest
    # This resource is type 'service' and title 'nginx'
    - type: service
      title: nginx
      parameters:
        ensure: running
    target:
      - web1.example.com
      - web2.example.com
      - web3.example.com
    description: "Set up nginx on the webservers"</code></pre></div></article></article><article class="topic nested2" aria-labelledby="ariaid-title11" id="parameters-key"><h3 class="title topictitle3" id="ariaid-title11">Parameters key</h3><div class="body"><p class="p">Plans accept parameters with the <code class="ph codeph">parameters</code> key. The value of <code class="ph codeph">parameters</code> is a map, where each key is the name of a parameter and the value is a map describing the parameter.</p><p class="p">Parameter values can be referenced from steps as variables.</p><p class="p">Parameters use these fields:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">type</code>: \(Optional\) A valid <a class="xref" href="https://puppet.com/docs/puppet/latest/lang_data.html#puppet-data-types" target="_blank">Puppet data type</a>. The value supplied must match the type or the plan fails.</p></li><li class="li"><p class="p"><code class="ph codeph">default</code>: \(Optional\) Used if no value is given for the parameter</p></li><li class="li"><p class="p"><code class="ph codeph">description</code>: \(Optional\)</p></li></ul><p class="p">For example, this plan accepts a <code class="ph codeph">load_balancer</code> name as a string, two sets of nodes called <code class="ph codeph">frontends</code> and <code class="ph codeph">backends</code>, and a <code class="ph codeph">version</code> string:</p><pre class="pre codeblock"><code>parameters:
  # A simple parameter definition doesn't need a type or description
  load_balancer:
  frontends:
    type: TargetSpec
    description: "The frontend web servers"
backends:
    type: TargetSpec
    description: "The backend application servers"
  version:
    type: String
              description: "The new application version to deploy"</code></pre></div></article><article class="topic nested2" aria-labelledby="ariaid-title12" id="how-strings-are-evaluated"><h3 class="title topictitle3" id="ariaid-title12">How strings are evaluated</h3><div class="body"><p class="p">The behavior of strings is defined by how theyre written in the plan.</p><p class="p"><code class="ph codeph">'single-quoted strings'</code> are treated as string literals without any interpolation.</p><p class="p"><code class="ph codeph">"double-quoted strings"</code> are treated as Puppet language double-quoted strings with variable interpolation.</p><p class="p"><code class="ph codeph">| block-style strings</code> are treated as expressions of arbitrary Puppet code. Note the string itself must be on a new line after the <code class="ph codeph">|</code> character.</p><p class="p"><code class="ph codeph">bare strings</code> are treated dynamically based on their content. If they begin with a <code class="ph codeph">$</code>, they're treated as Puppet code expressions. Otherwise, they're treated as YAML literals.</p><p class="p">Here's an example of different kinds of strings in use:</p><pre class="pre codeblock"><code>parameters:
  message:
    type: String
    default: "hello"

steps:
  - eval: hello
    description: 'This will evaluate to: hello'
  - eval: $message
    description: 'This will evaluate to: hello'
  - eval: '$message'
    description: 'This will evaluate to: $message'
  - eval: "${message} world"
    description: 'This will evaluate to: hello world'
  - eval: |
      [$message, $message, $message].join(" ")
    description: 'This will evaluate to: hello hello hello'</code></pre></div></article></article><article class="topic nested1" aria-labelledby="ariaid-title13" id="using-variables-and-simple-expressions"><h2 class="title topictitle2" id="ariaid-title13">Using variables and simple expressions</h2><div class="body"><p class="p">Parameters and step results are available as variables during plan execution, and they can be used to compute the value for each field of a step.</p><p class="p">The simplest way to use a variable is to reference it directly by name. For example, this plan takes a parameter called <code class="ph codeph">nodes</code> and passes it as the target list to a step:</p><pre class="pre codeblock"><code>parameters:
  nodes:
    type: TargetSpec

steps:
  - command: hostname -f
    target: $nodes</code></pre><p class="p">Variables can also be interpolated into string values. The string must be double-quoted to allow interpolation. For example:</p><pre class="pre codeblock"><code>parameters:
  username:
    type: String

steps:
  - task: echo
    message: "hello ${username}"
           target: $nodes</code></pre><p class="p">Many operations can be performed on variables to compute new values for step parameters or other fields.</p></div><article class="topic nested2" aria-labelledby="ariaid-title14" id="indexing-arrays-or-hashes"><h3 class="title topictitle3" id="ariaid-title14">Indexing arrays or hashes</h3><div class="body"><p class="p">You can retrieve a value from an Array or a Hash using the <code class="ph codeph">[]</code> operator. This operator can also be used when interpolating a value inside a string.</p><pre class="pre codeblock"><code>parameters:
  users:
    # Array[String] is a Puppet data type representing an array of strings
    type: Array[String]

steps:
  - task: user::add
    target: 'host.example.com'
    parameters:
      name: $users[0]
  - task: echo
    target: 'host.example.com'
    parameters:
      message: "hello ${users[0]}"</code></pre></div></article><article class="topic nested2" aria-labelledby="ariaid-title15" id="calling-functions"><h3 class="title topictitle3" id="ariaid-title15">Calling functions</h3><div class="body"><p class="p">You can call a built-in <a class="xref" href="plan_functions.html#">Bolt function</a> or <a class="xref" href="https://puppet.com/docs/puppet/latest/function.html" target="_blank">Puppet function</a> to compute a value.</p><pre class="pre codeblock"><code>parameters:
  users:
    type: Array[String]

steps:
  - task: user::add
    parameters:
      name: $users.first
  - task: echo
    message: "hello ${users.join(',')}"</code></pre></div></article><article class="topic nested2" aria-labelledby="ariaid-title16" id="using-code-blocks"><h3 class="title topictitle3" id="ariaid-title16">Using code blocks</h3><div class="body"><p class="p">Some Puppet functions take a block of code as an argument. For instance, you can filter an array of items based on the result of a block of code.</p><p class="p">The result of the <code class="ph codeph">filter</code> function is an array here, not a string, because the expression isn't inside quotes</p><pre class="pre codeblock"><code>parameters:
  numbers:
    type: Array[Integer]

steps:
  - task: sum
    description: "add up the numbers &gt; 5"
    parameters:
      indexes: $numbers.filter |$num| { $num &gt; 5 }</code></pre></div></article></article><article class="topic nested1" aria-labelledby="ariaid-title17" id="connecting-steps"><h2 class="title topictitle2" id="ariaid-title17">Connecting steps</h2><div class="body"><p class="p">You can connect multiple steps by using the result of one step to compute the parameters for another step.</p></div><article class="topic nested2" aria-labelledby="ariaid-title18" id="name-key"><h3 class="title topictitle3" id="ariaid-title18"><code class="ph codeph">name</code> key</h3><div class="body"><p class="p">The <code class="ph codeph">name</code> key makes its results available to later steps in a variable with that name.</p><p class="p">This example uses the <code class="ph codeph">map</code> function to get the value of <code class="ph codeph">stdout</code> from each command result and then joins them into a single string separated by commas.</p><pre class="pre codeblock"><code>parameters:
  nodes:
    type: TargetSpec

steps:
  - name: hostnames
    command: hostname -f
    target: $nodes
  - task: echo
    parameters:
      message: $hostnames.map |$hostname_result| { $hostname_result['stdout'] }.join(',')</code></pre></div></article><article class="topic nested2" aria-labelledby="ariaid-title19" id="eval-step"><h3 class="title topictitle3" id="ariaid-title19"><code class="ph codeph">eval</code> step</h3><div class="body"><p class="p">The <code class="ph codeph">eval</code> step evaluates an expression and saves the result in a variable. This is useful to compute a variable to use multiple times later.</p><pre class="pre codeblock"><code>parameters:
  count:
    type: Integer

steps:
  - name: double_count
    eval: $count * 2
  - task: echo
    target: web1.example.com
    parameters:
      message: "The count is ${count}, and twice the count is ${double_count}"</code></pre></div></article></article><article class="topic nested1" aria-labelledby="ariaid-title20" id="returning-results"><h2 class="title topictitle2" id="ariaid-title20">Returning results</h2><div class="body"><p class="p">You can return a result from a plan by setting the <code class="ph codeph">return</code> key at the top level of the plan. When the plan finishes, the <code class="ph codeph">return</code> key is evaluated and returned as the result of the plan. If no <code class="ph codeph">return</code> key is set, the plan returns <code class="ph codeph">undef</code>.</p><pre class="pre codeblock"><code>steps:
  - name: hostnames
    command: hostname -f
    target: $nodes

return: $hostnames.map |$hostname_result| { $hostname_result['stdout'] }</code></pre></div></article><article class="topic nested1" aria-labelledby="ariaid-title21" id="computing-complex-values"><h2 class="title topictitle2" id="ariaid-title21">Computing complex values</h2><div class="body"><p class="p">To compute complex values, you can use a Puppet code expression as the value of any field of a step except the <code class="ph codeph">name</code>.</p><p class="p">Bolt loads the plan as a YAML data structure. As it executes each step, it evaluates any expressions embedded in the step. Each plan parameter and the values of every previous named step are available in scope.</p><p class="p">This lets you take advantage of the power of Puppet language in the places it's necessary, while keeping the rest of your plan simple.</p><p class="p">When your plans need more sophisticated control flow or error handling beyond running a list of steps in order, it's time to convert them to <a class="xref" href="writing_plans.html#">Puppet language plans</a>.</p></div></article><article class="topic nested1" aria-labelledby="ariaid-title22" id="converting-yaml-plans-to-puppet-plans"><h2 class="title topictitle2" id="ariaid-title22">Converting YAML plans to Puppet plans</h2><div class="body"><p class="p">You can convert a YAML plan to a Puppet plan with the <code class="ph codeph">bolt plan convert</code> command.</p><pre class="pre codeblock"><code>bolt plan convert path/to/my/plan.yaml</code></pre><p class="p">This command takes the relative or absolute path to the YAML plan to be converted and prints the converted Puppet plan to stdout.</p><p class="p"><strong class="ph b">Note:</strong> Converting a YAML plan might result in a Puppet plan which is syntactically correct, but behaviorally different from its YAML plan. Always manually verify a converted Puppet plan's functionality. If you convert a YAML plan to Puppet and it doesn't have the same behavior as the YAML plan, you can <a class="xref" href="https://github.com/puppetlabs/bolt/issues" target="_blank">file an issue in our</a>Git repo.</p><p class="p">For example, with this YAML plan:</p><pre class="pre codeblock"><code># site-modules/mymodule/plans/yamlplan.yaml
parameters:
  nodes:
    type: TargetSpec
steps:
  - name: run_task
    task: sample
    target: $nodes
    parameters:
      message: "hello world"
return: $run_task</code></pre><p class="p">Run the following conversion:</p><pre class="pre codeblock"><code>$ bolt plan convert site-modules/mymodule/plans/yamlplan.yaml
# WARNING: This is an autogenerated plan. It may not behave as expected.
plan mymodule::yamlplan(
  TargetSpec $nodes
) {
  $run_task = run_task('sample', $nodes, {'message' =&gt; "hello world"})
  return $run_task
}</code></pre></div></article></article></main></body></html>