<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2019"><meta name="DC.rights.owner" content="(C) Copyright 2019"><meta name="DC.type" content="topic"><meta name="DC.creator" content="Kate Lopresti <kate.lopresti@puppet.com\&gt;"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="applying-manifest-blocks"><link rel="stylesheet" type="text/css" href="commonltr.css"><title>Applying manifest blocks</title></head><body id="applying-manifest-blocks"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">Applying manifest blocks</h1><div class="body"><p class="p">Within a plan, you can use Bolt to apply blocks of Puppet code \(manifest blocks\) to remote nodes.&nbsp;</p><p class="p">Similar to the <code class="ph codeph">puppet apply</code> command, which applies a standalone Puppet manifest to a local system, the Bolt <code class="ph codeph">apply</code> command leverages manifest blocks to pass code to remote nodes from the command line. You can create manifest blocks that use existing content from the Forge, or mix declarative resource configuration via manifest blocks with procedural orchestration and action in a plan. Most features of the Puppet language are available in a manifest block: classes, custom resource types, and functions. For information about what language features aren't supported, see <a class="xref" href="applying_manifest_blocks.html#">Manifest block limitations</a>.</p><p class="p"><strong class="ph b">Tip:</strong> If you installed Bolt as a Ruby gem, make sure you have installed the core modules required to use the <code class="ph codeph">puppet apply</code> command. These modules are listed in the <a class="xref" href="https://github.com/puppetlabs/bolt/blob/master/Puppetfile" target="_blank">Bolt GitHub repository</a>and you can install them using a Puppetfile.</p><p class="p"><strong class="ph b">Related information</strong></p><p class="p"><a class="xref" href="bolt_installing_modules.html#">Configure Bolt to download and install modules</a></p><p class="p"><a class="xref" href="https://github.com/puppetlabs/bolt/blob/master/Puppetfile" target="_blank">Puppetfile example</a></p><p class="p"><a class="xref" href="https://forge.puppet.com/" target="_blank">Puppet Forge</a></p></div><article class="topic nested1" aria-labelledby="ariaid-title2" id="how-manifest-blocks-are-applied"><h2 class="title topictitle2" id="ariaid-title2">How manifest blocks are applied</h2><div class="body"><p class="p">When you run a plan that contains a manifest block, the <code class="ph codeph">apply_prep</code> function installs the packages necessary to run the Bolt <code class="ph codeph">apply</code> command.</p><p class="p">The <code class="ph codeph">apply_prep</code> function identifies the nodes that do not have Puppet agents and runs the <code class="ph codeph">puppet_agent::install</code> task \(from the <a class="xref" href="https://forge.puppet.com/puppetlabs/puppet_agent" target="_blank">puppet\_agent module</a>\). It also copies over custom facts from the Bolt modulepath and runs <a class="xref" href="https://puppet.com/docs/facter/latest/" target="_blank">facter</a> on the target nodes.</p><p class="p">Behind the scenes, Bolt compiles the code in your manifest block \(the code wrapped in curly braces that follows the <code class="ph codeph">apply</code> function\) into a catalog. Code is compiled in the following order:</p><ul class="ul"><li class="li"><p class="p">Facts gathered from the targets or set in your inventory.</p></li><li class="li"><p class="p">Local variables in the plan, such as <code class="ph codeph">$site_content.</code></p></li><li class="li"><p class="p"><a class="xref" href="inventory_file.html#title-1541705359297"><code class="ph codeph">Vars</code></a> set in your inventory.</p></li></ul><p class="p">Like the code compiled with the <code class="ph codeph">puppet apply</code> function, all the variables are generated. As a result, you can reuse code between Bolt and Puppet. Bolt then copies custom module content from the Bolt modulepath to the target nodes and applies the catalog using Puppet.</p><p class="p">After the catalog compiles and is executed successfully on all targets, <code class="ph codeph">apply</code> returns the reports generated by applying the catalog on each node.</p></div><article class="topic nested2" aria-labelledby="ariaid-title3" id="options-for-apply-action"><h3 class="title topictitle3" id="ariaid-title3">Options for Apply action</h3><div class="body"><p class="p">The <code class="ph codeph">apply</code> action supports the following options:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">_catch_errors =&gt; true</code> returns a <code class="ph codeph">ResultSet</code> including failed results, rather than failing the plan.</p></li><li class="li"><p class="p"><code class="ph codeph">_noop =&gt; true</code> applies the manifest block in Puppet no-operation mode, returning a report of the changes it would make, but takes no action.</p></li><li class="li"><p class="p"><code class="ph codeph">_run_as =&gt; &lt;USER&gt;</code> applies the manifest block as the specified user. \(This option is for transports that allow a user to run commands under a different username.\)</p><pre class="pre codeblock"><code># Preview installing docker as root on $nodes.
apply($nodes, _catch_errors =&gt; true, _noop =&gt; true, _run_as =&gt; root) {
   include 'docker'
}</code></pre></li></ul></div></article><article class="topic nested2" aria-labelledby="ariaid-title4" id="return-value-of-apply-action"><h3 class="title topictitle3" id="ariaid-title4">Return value of Apply action</h3><div class="body"><p class="p">The <code class="ph codeph">apply</code> action returns an object type <code class="ph codeph">ResultSet</code> that contains <code class="ph codeph">ApplyResult</code> object for each target. For more information on the methods you can call on <code class="ph codeph">$result</code>, see <a class="xref" href="writing_plans.html#">Handling plan function results</a>.</p><pre class="pre codeblock"><code>$results = apply($nodes) { ... }
$results.each |$result| {
   notice($result.report)
}</code></pre></div></article><article class="topic nested2" aria-labelledby="ariaid-title5" id="configuring-concurrency"><h3 class="title topictitle3" id="ariaid-title5">Configuring concurrency</h3><div class="body"><p class="p">Each target requires a separate catalog be compiled with its unique facts and <code class="ph codeph">Vars</code>. The apply action compiles and applies catalogs in parallel on the Bolt host. Concurrency of catalog compilation is controlled by a <code class="ph codeph">compile-concurrency</code> config option. This option is limited to twice the number of threads your CPU can run concurrently. Catalog application, on the other hand, uses the Bolt default thread pool controlled by the <code class="ph codeph">concurrency</code> option.</p></div></article></article><article class="topic nested1" aria-labelledby="ariaid-title6" id="using-hiera-data-in-a-manifest-block"><h2 class="title topictitle2" id="ariaid-title6">Using Hiera data in a manifest block</h2><div class="body"><p class="p">Use Hiera to separate configuration from context-specific data, where context may be fact-based or the name of a target.</p><p class="p"><strong class="ph b">Note:</strong> Only Hiera version 5 is supported in Bolt.</p><p class="p">Hiera is a key-value configuration data lookup system, used for separating data from Puppet code. You use Hiera data to implicitly override default class parameters. You can also explicitly lookup data from Hiera via lookup, for example:</p><pre class="pre codeblock"><code>plan do_thing() {
  apply('localhost') {
    notice("Some data in Hiera: ${lookup('mydata')}")
  }
}</code></pre><p class="p">Manifest block compilation can access Hiera data that you add to your Bolt configuration. The default location for Hiera config is <code class="ph codeph">$BOLTDIR/hiera.yaml</code>; you can change this with the <code class="ph codeph">hiera-config</code>key in a Bolt config file.</p><p class="p">Following the Hiera 5 convention, the default data dir is relative to <code class="ph codeph">hiera.yaml</code> at <code class="ph codeph">$BOLTDIR/data</code>. For config file examples, see <a class="xref" href="https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html" target="_blank">Configuring Hiera</a>.</p><p class="p">If a custom data provider is used \(such as <code class="ph codeph">hiera-eyaml</code>, which allows you to encrypt your data\) the gem dependencies must be available to Bolt. See <a class="xref" href="bolt_installing.html#">Install gems with Bolt packages</a>.</p><p class="p"><strong class="ph b">Related information</strong></p><p class="p"><a class="xref" href="configuring_bolt.html">Configuring Bolt</a></p></div></article><article class="topic nested1" aria-labelledby="ariaid-title7" id="available-plan-functions"><h2 class="title topictitle2" id="ariaid-title7">Available plan functions</h2><div class="body"><p class="p">In addition to the standard Puppet functions available to a catalog, such as <code class="ph codeph">lookup</code>, you can use the following Bolt functions in a manifest block.</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">[puppetdb\_query](plan_functions.md#)</code></p></li><li class="li"><p class="p"><code class="ph codeph">[puppetdb\_facts](plan_functions.md#)</code></p></li><li class="li"><p class="p"><code class="ph codeph">[get\_targets](plan_functions.md#)</code></p></li><li class="li"><p class="p"><code class="ph codeph">[facts](plan_functions.md#)</code></p></li><li class="li"><p class="p"><code class="ph codeph">[vars](plan_functions.md#)</code></p></li></ul></div></article><article class="topic nested1" aria-labelledby="ariaid-title8" id="manifest-block-limitations"><h2 class="title topictitle2" id="ariaid-title8">Manifest block limitations</h2><div class="body"><p class="p">Exported resources are not supported in manifest blocks. You must pass exported resources directly instead of exporting and collecting them from PuppetDB. If you need to interact with resources managed during a normal run, use the function <code class="ph codeph">puppetdb_query</code>.</p><p class="p">In addition, the following top-level variables, which exist in normal catalog compilation, are not included during manifest block compilation:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">$server_facts</code></p></li><li class="li"><p class="p">master variables like <code class="ph codeph">$servername</code></p></li><li class="li"><p class="p">$<code class="ph codeph">environment</code></p></li></ul><p class="p">You can optionally set these from a target's <code class="ph codeph">vars</code>, but they don't have defaults in Bolt.</p><p class="p"><strong class="ph b">Related information</strong></p><p class="p"><a class="xref" href="plan_functions.html#">puppetdb\_query</a></p></div></article><article class="topic nested1" aria-labelledby="ariaid-title9" id="create-a-sample-manifest-for-nginx-on-linux"><h2 class="title topictitle2" id="ariaid-title9">Create a sample manifest for nginx on Linux</h2><div class="body"><p class="p">Create a manifest that sets up a web server with nginx, and run it as a plan.</p><ol class="ol"><li class="li"><p class="p">Go to the <code class="ph codeph">site-modules</code> directory in the default Bolt project directory: <code class="ph codeph">~/.puppetlabs/bolt/site-modules</code></p></li><li class="li"><p class="p">Create a module named profiles.</p><ul class="ul"><li class="li"><p class="p">If you use the Puppet Development Kit: <code class="ph codeph">pdk new module profiles</code></p></li><li class="li"><p class="p">Otherwise create <code class="ph codeph">~/.puppetlabs/bolt/site-modules/profiles</code></p></li></ul></li><li class="li"><p class="p">Add a <code class="ph codeph">plans</code> directory&nbsp;to the profiles module.</p></li><li class="li"><p class="p">In the plans directory, create a manifest file called nginx\_install.pp and add the following code:</p><pre class="pre codeblock"><code>plan profiles::nginx_install(
     TargetSpec $nodes,
     String $site_content = 'hello!',
   ) {

     # Install the puppet-agent package if Puppet is not detected.
     # Copy over custom facts from the Bolt modulepath.
     # Run the `facter` command line tool to gather node information.
     $nodes.apply_prep

     # Compile the manifest block into a catalog
     apply($nodes) {
       if($facts['os']['family'] == 'redhat') {
         package { 'epel-release':
           ensure =&gt; present,
           before =&gt; Package['nginx'],
         }
         $html_dir = '/usr/share/nginx/html'
       } else {
         $html_dir = '/var/www/html'
       }

       package {'nginx':
         ensure =&gt; present,
       }

       file {"${html_dir}/index.html":
         content =&gt; $site_content,
         ensure  =&gt; file,
       }

       service {'nginx':
         ensure  =&gt; 'running',
         enable  =&gt; 'true',
         require =&gt; Package['nginx']
       }
     }
   }</code></pre></li><li class="li"><p class="p">Run the plan on a target node:</p><pre class="pre codeblock"><code>bolt plan run profiles::nginx_install --nodes mynode.mydomain</code></pre></li><li class="li"><p class="p">In a web browser, open <code class="ph codeph">mynode.mydomain</code></p><p class="p">The page displays the text <strong class="ph b">hello!</strong></p></li></ol><p class="p"><strong class="ph b">Tip:</strong> For complex web server deployments, consider adding the&nbsp;<a class="xref" href="https://forge.puppet.com/puppet/nginx" target="_blank">puppet-nginx</a>&nbsp;module.</p><p class="p"><strong class="ph b">Related information</strong></p><p class="p"><a class="xref" href="https://www.nginx.com/resources/glossary/nginx/" target="_blank">NGINX</a></p><p class="p"><a class="xref" href="bolt_options.html#">Specify target nodes</a></p><p class="p"><a class="xref" href="bolt_project_directories.html#">Project directories</a></p></div></article><article class="topic nested1" aria-labelledby="ariaid-title10" id="create-a-sample-manifest-for-iis-on-windows"><h2 class="title topictitle2" id="ariaid-title10">Create a sample manifest for IIS on Windows</h2><div class="body"><p class="p">Create a manifest that sets up a web server with IIS and run it as a plan.</p><ol class="ol"><li class="li"><p class="p">Go to the <code class="ph codeph">site-modules</code> directory in the default Bolt project directory: <code class="ph codeph">~/.puppetlabs/bolt/site-modules</code></p></li><li class="li"><p class="p">Create a module named profiles.</p><ul class="ul"><li class="li"><p class="p">If you use the Puppet Development Kit: <code class="ph codeph">pdk new module profiles</code></p></li><li class="li"><p class="p">Otherwise create <code class="ph codeph">~/.puppetlabs/bolt/site-modules/profiles</code></p></li></ul></li><li class="li"><p class="p">Add a <code class="ph codeph">plans</code> directory&nbsp;to the profiles module.</p></li><li class="li"><p class="p">Install the IIS dependencies.</p><ol class="ol" type="a"><li class="li"><p class="p">Add the following code to <code class="ph codeph">~/.puppetlabs/bolt/Puppetfile</code></p><pre class="pre codeblock"><code>forge 'http://forge.puppetlabs.com'
mod 'puppetlabs-iis', '4.3.2'
mod 'profiles', local: true</code></pre></li><li class="li"><p class="p">Run <code class="ph codeph">bolt puppetfile install</code></p></li></ol></li><li class="li"><p class="p">In the plans directory, create a manifest file called iis\_install.pp and add the following code:</p><pre class="pre codeblock"><code>plan profiles::iis_install(
     TargetSpec $nodes,
     String $site_content = 'hello!',
   ) {

     # Install the puppet-agent package if Puppet is not detected. 
     # Copy over custom facts from the Bolt modulepath.
     # Run the `facter` command line tool to gather node information.
     $nodes.apply_prep

     # Compile the manifest block into a catalog
     return apply($nodes, '_catch_errors' =&gt; true) {
       $iis_features = ['Web-WebServer','Web-Scripting-Tools']

       iis_feature { $iis_features:
         ensure =&gt; 'present',
       }

       # Delete the default website to prevent a port binding conflict.
       iis_site {'Default Web Site':
         ensure  =&gt; absent,
         require =&gt; Iis_feature['Web-WebServer'],
       }

       iis_site { 'minimal':
         ensure          =&gt; 'started',
         physicalpath    =&gt; 'c:\\inetpub\\minimal',
         applicationpool =&gt; 'DefaultAppPool',
         require         =&gt; [
           File['minimal'],
           Iis_site['Default Web Site']
         ],
       }

       file { 'minimal':
         ensure =&gt; 'directory',
         path   =&gt; 'c:\\inetpub\\minimal',
       }

       file { 'content':
         ensure  =&gt; 'file',
         path    =&gt; 'c:\\inetpub\\minimal\\index.html',
         content =&gt; $site_content,
       }
     }
   }</code></pre></li><li class="li"><p class="p">Run the plan on a target node:</p><pre class="pre codeblock"><code>bolt plan run profiles::iis_install --nodes mynode.mydomain --transport winrm</code></pre></li><li class="li"><p class="p">In a web browser, open <code class="ph codeph">mynode.mydomain</code></p><p class="p">The page displays the text <strong class="ph b">hello!</strong></p></li></ol><p class="p"><strong class="ph b">Related information</strong></p><p class="p"><a class="xref" href="https://www.iis.net" target="_blank">IIS</a></p><p class="p"><a class="xref" href="bolt_options.html#">Specify target nodes</a></p><p class="p"><a class="xref" href="bolt_project_directories.html#">Project directories</a></p></div></article><article class="topic nested1" aria-labelledby="ariaid-title11" id="using-puppet-device-modules-from-an-apply-statement"><h2 class="title topictitle2" id="ariaid-title11">Using Puppet device modules from an apply statement</h2><div class="body"><p class="p">Puppet device modules based on remote transports allow network devices and other targets that can't run a Puppetagent to be managed from a proxy.</p><p class="p"><strong class="ph b">Note:</strong> Support for device modules is experimental and might change in future minor \(y\) releases.</p><p class="p">To use device modules from an apply statement, the devices must be added to the Bolt inventory as remote targets. The <code class="ph codeph">name</code> of the target will be used to auto-populate the <code class="ph codeph">name</code>, <code class="ph codeph">uri</code>, <code class="ph codeph">user</code>, <code class="ph codeph">password</code>, <code class="ph codeph">host</code>, and <code class="ph codeph">port</code> fields of the remote transport's connnection info. You must set the <code class="ph codeph">remote-transport</code> option and any other connnection info under the <code class="ph codeph">remote</code> section of config.</p><pre class="pre codeblock"><code>---
nodes:
  - name: "https://username:password@panos-device.example.com"
    config:
      transport: remote
      remote:
       remote-transport: panos</code></pre><p class="p">When you set the <code class="ph codeph">run-on</code> option with a device module, the puppet-resource\_api gem be must installed with the puppet agent on the proxy target and it must be version 1.8.1 or later.</p></div></article></article></main></body></html>