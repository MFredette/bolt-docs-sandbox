<?xml version="1.0" encoding="UTF-8"?><?path2rootmap-uri ./?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="writing-plans-in-puppet-language"><title>Writing plans in Puppet language</title><prolog><author>Jean Bond &lt;jean@puppet.com\&gt;</author></prolog><body><p>Plans allow you to run more than one task with a single command, compute values for the input to a task, process the results of tasks, or make decisions based on the result of running a task.</p><p>Write plans in the Puppet language, giving them a <codeph>.pp</codeph> extension, and place them in the module's <codeph>/plans</codeph> directory.</p><p>Plans can use any combination of <xref href="plan_functions.md#" format="dita" type="topic">Bolt functions</xref> or <xref href="https://puppet.com/docs/puppet/6.1/function.html" format="html" scope="external">built-in Puppet functions</xref>.</p><p><b>Parent topic:</b><xref href="writing_tasks_and_plans.md" format="dita" type="topic">Tasks and plans</xref></p><p><b>Related information</b></p><p><xref href="writing_yaml_plans.md#" format="dita" type="topic">Converting YAML plans to Puppet plans</xref></p></body><topic id="naming-plans"><title>Naming plans</title><body><p>Plan names are named based on the filename of the plan, the name of the module containing the plan, and the path to the plan within the module.</p><p>Place plan files in your module's <codeph>./plans</codeph> directory, using these file extensions:</p><ul><li><p>Puppet plans — <codeph>.pp</codeph></p></li><li><p>YAML plans — <codeph>.yaml</codeph>, not <codeph>.yml</codeph></p></li></ul><p>Plan names are composed of two or more name segments, indicating:</p><ul><li><p>The name of the module the plan is located in.</p></li><li><p>The name of the plan file, without the extension.</p></li><li><p>The path within the module, if the plan is in a subdirectory of <codeph>./plans</codeph>.</p></li></ul><p>For example, given a module called <codeph>mymodule</codeph> with a plan defined in <codeph>./mymodule/plans/myplan.pp</codeph>, the plan name is <codeph>mymodule::myplan</codeph>. A plan defined in <codeph>./mymodule/plans/service/myplan.pp</codeph>would be <codeph>mymodule::service::myplan</codeph>. This name is how you refer to the plan when you run commands.</p><p>The plan filename <codeph>init</codeph> is special: the plan it defines is referenced using the module name only. For example, in a module called <codeph>mymodule</codeph>, the plan defined in <codeph>init.pp</codeph> is the <codeph>mymodule</codeph> plan.</p><p>Avoid giving plans the same names as constructs in the Puppet language. Although plans do not share their namespace with other language constructs, giving plans these names makes your code difficult to read.</p><p>Each plan name segment must begin with a lowercase letter and:</p><ul><li><p>May include lowercase letters.</p></li><li><p>May include digits.</p></li><li><p>May include underscores.</p></li><li><p>Must not be a <xref href="https://docs.puppet.com/puppet/5.3/lang_reserved.html" format="html" scope="external">reserved word</xref>.</p></li><li><p>Must not have the same name as any Puppet data types.</p></li><li><p>Namespace segments must match the following regular expression <codeph>\A[a-z][a-z0-9_]*\Z</codeph></p></li></ul></body></topic><topic id="defining-plan-parameters"><title>Defining plan parameters</title><body><p>You can specify parameters in your plan.</p><p>Specify each parameter in your plan with its data type. For example, you might want parameters to specify which nodes to run different parts of your plan on.</p><p>The following example shows node parameters specified as data type <codeph>TargetSpec</codeph>. This allows this parameter to be passed as a single URL, comma-separated URL list, Target data type, or Array of either. For more information about these data types, see the common data types table in the related metadata type topic.</p><p>This allows the user to pass, for each parameter, either a node name or a URI that describes the protocol to use, the hostname, username, and password.</p><p>The plan then calls the <codeph>run_task</codeph> function, specifying which nodes the tasks should be run on. The <codeph>Target</codeph> names are collected and stored in <codeph>$webserver_names</codeph> by iterating over the list of <codeph>Target</codeph> objects returned by <codeph>get_targets</codeph>. Task parameters are serialized to JSON format; therefore, extracting the names into an array of strings ensures that the <codeph>webservers</codeph> parameter is in a format that can be converted to JSON.</p><codeblock xml:space="preserve">plan mymodule::my_plan(
  TargetSpec $load_balancer,
  TargetSpec  $webservers,
) {

  # Extract the Target name from $webservers
  $webserver_names = get_targets($nodes).map |$n| { $n.name }
  
  # process webservers
  run_task('mymodule::lb_remove', $load_balancer, webservers =&gt; $webserver_names)
  run_task('mymodule::update_frontend_app', $webservers, version =&gt; '1.2.3')
  run_task('mymodule::lb_add', $load_balancer, webservers =&gt; $webserver_names)
 }</codeblock><p>To execute this plan from the command line, pass the parameters as <codeph>parameter=value</codeph>. The <codeph>Targetspec</codeph> accepts either an array as json or a comma separated string of target names.</p><codeblock xml:space="preserve">bolt plan run mymodule::myplan --modulepath ./PATH/TO/MODULES load_balancer=lb.myorg.com webservers='["kermit.myorg.com","gonzo.myorg.com"]'
        </codeblock><p>Parameters that are passed to the <codeph>run_*</codeph> plan functions are serialized to JSON.</p><p>To illustrate this concept, consider this plan:</p><codeblock xml:space="preserve">plan test::parameter_passing (
  TargetSpec $nodes,
  Optional[String[1]] $example_nul = undef,
) {
  return run_task('test::demo_undef_bash', $nodes, example_nul =&gt; $example_nul)
     }</codeblock><p>The default value of <codeph>$example_nul</codeph> is <codeph>undef</codeph>. The plan calls the <codeph>test::demo_undef_bash</codeph> with the <codeph>example_nul</codeph> parameter. The implementation of the <codeph>demo_undef_bash.sh</codeph> task is:</p><codeblock xml:space="preserve">#!/bin/bash
example_env=$PT_example_nul
echo "Environment: $PT_example_nul"
echo "Stdin:" 
     cat -</codeblock><p>By default, the task expects parameters passed as a JSON string on stdin to be accessible in prefixed environment variables.</p><p>Consider the output of running the plan against localhost:</p><codeblock xml:space="preserve">bolt@bolt: bolt plan run test::parameter_passing -n localhost
Starting: plan test::parameter_passing
Starting: task test::demo_undef_bash on localhost
Finished: task test::demo_undef_bash with 0 failures in 0.0 sec
Finished: plan test::parameter_passing in 0.01 sec
Finished on localhost:
  Environment: null
  Stdin:
  {"example_nul":null,"_task":"test::demo_undef_bash"}
  {
  }
Successful on 1 node: localhost
     Ran on 1 node</codeblock><p>The parameters <codeph>example_nul</codeph> and <codeph>_task</codeph> metadata are passed to the task as a JSON string over stdin.</p><p>Similarly, parameters are made available to the task as environment variables where the name of the parameter is converted to an environment variable prefixed with <codeph>PT_</codeph>. The prefixed environment variable points to the <codeph>String</codeph> representation in <codeph>JSON</codeph> format of the parameter value. So, the <codeph>PT_example_nul</codeph> environment variable has the value of <codeph>null</codeph> of type <codeph>String</codeph>.</p><p><b>Related information</b></p><p><xref href="writing_tasks.md#" format="dita" type="topic">Task metadata types</xref></p></body></topic><topic id="returning-results-from-plans"><title>Returning results from plans</title><body><p>Use plans to return results that you can use in other plans or save for use outside of Bolt.</p><p>Plans, unlike functions, are primarily run for side effects but they can optionally return a result. To return a result from a plan use the <codeph>return</codeph> function. Any plan that does not call the <codeph>return</codeph> function returns <codeph>undef</codeph>.</p><codeblock xml:space="preserve">plan return_result(
  $nodes
) {
  return run_task('mytask', $nodes)
}</codeblock><p>The result of a plan must match the <codeph>PlanResult</codeph> type alias. This roughly includes JSON types as well as the Plan language types which have well defined JSON representations in Bolt.</p><ul><li><p><codeph>Undef</codeph></p></li><li><p><codeph>String</codeph></p></li><li><p><codeph>Numeric</codeph></p></li><li><p><codeph>Boolean</codeph></p></li><li><p><codeph>Target</codeph></p></li><li><p><codeph>Result</codeph></p></li><li><p><codeph>ResultSet</codeph></p></li><li><p><codeph>Error</codeph></p></li><li><p><codeph>Array</codeph> with only <codeph>PlanResult</codeph></p></li><li><p>Hash with <codeph>String</codeph> keys and <codeph>PlanResult</codeph> values</p></li></ul><p>or</p><codeblock xml:space="preserve">Variant[Data, String, Numeric, Boolean, Error, Result, ResultSet, Target, Array[Boltlib::PlanResult], Hash[String, Boltlib::PlanResult]]
</codeblock></body></topic><topic id="returning-errors-in-plans"><title>Returning errors in plans</title><body><p>To return an error if your plan fails, call the <codeph>fail_plan</codeph> function.</p><p>Specify parameters to provide details about the failure.</p><p>For example, if called with <codeph>run_plan('mymodule::myplan')</codeph>, this would return an error to the caller.</p><codeblock xml:space="preserve">plan mymodule::myplan {
  Error(
    message    =&gt; "Sorry, this plan does not work yet.",
    kind       =&gt; 'mymodule/error',
    issue_code =&gt; 'NOT_IMPLEMENTED'
    )
  }
  fail_plan("Sorry, this plan does not work yet.", 'mymodule/error')
}

</codeblock></body></topic><topic id="success-and-failure-in-plans"><title>Success and failure in plans</title><body><p>Indicators that a plan has run successfully or failed.</p><p>Any plan that completes execution without an error is considered successful. The <codeph>bolt</codeph> command exits 0 and any calling plans continue execution. If any calls to <codeph>run_</codeph> functions fail <b>without</b> <codeph>_catch_errors</codeph> then the plan halts execution and is considered a failure. Any calling plans also halt until a <codeph>run_plan</codeph> call with <codeph>_catch_errors</codeph> or a <codeph>catch_errors</codeph> block is reached. If one isn't reached, the <codeph>bolt</codeph> command performs an exit 2. When writing a plan if you have reason to believe it has failed, you can fail the plan with the <codeph>fail_plan</codeph> function. This causes the bolt command to exit 2 and prevents calling plans executing any further, unless <codeph>run_plan</codeph> was called with <codeph>_catch_errors</codeph> or in a <codeph>catch_errors</codeph> block.</p></body><topic id="failing-plans"><title>Failing plans</title><body><p>If <codeph>upload_file</codeph>, <codeph>run_command</codeph>, <codeph>run_script</codeph>, or <codeph>run_task</codeph> are called without the <codeph>_catch_errors</codeph> option and they fail on any nodes, the plan itself fails. To fail a plan directly call the <codeph>fail_plan</codeph> function. Create a new error with a message and include the kind, details, or issue code, or pass an existing error to it.</p><codeblock xml:space="preserve">fail_plan('The plan is failing', 'mymodules/pear-shaped', {'failednodes' =&gt; $result.error_set.names})
# or
fail_plan($errorobject)</codeblock></body></topic><topic id="catching-errors-in-plans"><title>Catching errors in plans</title><body><p>Bolt includes a <codeph>catch_errors</codeph> function that executes a block of code and returns the error if an error is raised, or returns the result of the block if no errors are raised. You might get an <codeph>Error</codeph> object returned if you call <codeph>run_plan</codeph> with <codeph>_catch_errors</codeph>, use a <codeph>catch_errors</codeph> block, or call the <codeph>Error</codeph> method on a result.</p><p>The <codeph>Error</codeph> data type includes:</p><ul><li><p><codeph>msg</codeph>: The error message string.</p></li><li><p><codeph>kind</codeph>: A string that defines the kind of error similar to an error class.</p></li><li><p><codeph>details</codeph>: A hash with details about the error from a task or from information about the state of a plan when it fails, for example, <codeph>exit_code</codeph> or <codeph>stack_trace</codeph>.</p></li><li><p><codeph>issue_code</codeph>: A unique code for the message that can be used for translation.</p></li></ul><p>Use the <codeph>Error</codeph> data type in a case expression to match against different kind of errors. To recover from certain errors, while failing on or ignoring others, set up your plan to include conditionals based on errors that occur while your plan runs. For example, you can set up a plan to retry a task when a timeout error occurs, but to fail when there is an authentication error.</p><p>Below, the first plan continues whether it succeeds or fails with a<codeph>mymodule/not-serious</codeph>error. Other errors cause the plan to fail.</p><codeblock xml:space="preserve">plan mymodule::handle_errors {
  $result = run_plan('mymodule::myplan', '_catch_errors' =&gt; true)
  case $result {
    Error['mymodule/not-serious'] : {
      notice("${result.message}")
    }
    Error : { fail_plan($result) } }
  run_plan('mymodule::plan2')
}
</codeblock><p>Using the <codeph>catch_errors</codeph> function:</p><codeblock xml:space="preserve">plan test (String[1] $role) {
  $result_or_error = catch_errors(['bolt/puppetdb-error']) || {
    puppetdb_query("inventory[certname] { app_role == ${role} }")
  }
  $targets = if $result_or_error =~ Error {
    # If the PuppetDB query fails
    warning("Could not fetch from puppet. Using defaults instead")
    # TargetSpec string
    "all"
  } else {
    $result_or_error
  }
}</codeblock></body></topic></topic><topic id="puppet-and-ruby-functions-in-plans"><title>Puppet and Ruby functions in plans</title><body><p>You can define and call Puppet language and Ruby functions in plans.</p><p>This is useful for packaging common general logic in your plan. You can also call the plan functions, such as <codeph>run_task</codeph> or <codeph>run_plan</codeph>, from within a function.</p><p>Not all Puppet language constructs are allowed in plans. The following constructs are not allowed:</p><ul><li><p>Defined types.</p></li><li><p>Classes.</p></li><li><p>Resource expressions, such as <codeph>file { title: mode =&gt; '0777' }</codeph></p></li><li><p>Resource default expressions, such as <codeph>File { mode =&gt; '0666' }</codeph></p></li><li><p>Resource overrides, such as <codeph>File['/tmp/foo'] { mode =&gt; '0444' }</codeph></p></li><li><p>Relationship operators: <codeph>-&gt; &lt;- ~&gt; &lt;~</codeph></p></li><li><p>Functions that operate on a catalog: <codeph>include</codeph>, <codeph>require</codeph>, <codeph>contain</codeph>, <codeph>create_resources</codeph>.</p></li><li><p>Collector expressions, such as <codeph>SomeType &lt;| |&gt;</codeph>, <codeph>SomeType &lt;&lt;| |&gt;&gt;</codeph></p></li><li><p>ERB templates are not supported. Use EPP instead.</p></li></ul><p>You should be aware of some other Puppet behaviors in plans:</p><ul><li><p>The <codeph>--strict_variables</codeph> option is on, so if you reference a variable that is not set, you get an error.</p></li><li><p><codeph>--strict=error</codeph> is always on, so minor language issues generate errors. For example <codeph>{ a =&gt; 10, a =&gt; 20 }</codeph> is an error because there is a duplicate key in the hash.</p></li><li><p>Most Puppet settings are empty and not-configurable when using Bolt.</p></li><li><p>Logs include "source location" \(file, line\) instead of resource type or name.</p></li></ul></body></topic><topic id="handling-plan-function-results"><title>Handling plan function results</title><body><p>Plan execution functions each return a result object that returns details about the execution.</p><p>Each <xref href="plan_functions.md#" format="dita" type="topic">execution function</xref> returns an object type <codeph>ResultSet</codeph>. For each node that the execution takes place on, this object contains a <codeph>Result</codeph> object. The <xref href="applying_manifest_blocks.md#" format="dita" type="topic">apply action</xref> returns a <codeph>ResultSet</codeph> containing <codeph>ApplyResult</codeph> objects.</p><p>A <codeph>ResultSet</codeph> has the following methods:</p><ul><li><p><codeph>names()</codeph>: The <codeph>String</codeph> names \(node URIs\) of all nodes in the set as an <codeph>Array</codeph>.</p></li><li><p><codeph>empty()</codeph>: Returns <codeph>Boolean</codeph> if the execution result set is empty.</p></li><li><p><codeph>count()</codeph>: Returns an <codeph>Integer</codeph> count of nodes.</p></li><li><p><codeph>first()</codeph>: The first <codeph>Result</codeph> object, useful to unwrap single results.</p></li><li><p><codeph>find(String $target_name)</codeph>: Look up the <codeph>Result</codeph> for a specific target.</p></li><li><p><codeph>error_set()</codeph>: A <codeph>ResultSet</codeph>containing only the results of failed nodes.</p></li><li><p><codeph>ok_set()</codeph>: A <codeph>ResultSet</codeph> containing only the successful results.</p></li><li><p><codeph>filter_set(block)</codeph>: Filters a <codeph>ResultSet</codeph> with the given block and returns a <codeph>ResultSet</codeph> object \(where the <xref href="https://puppet.com/docs/puppet/latest/function.html#filter" format="html" scope="external">filter function</xref> returns an array or hash\).</p></li><li><p><codeph>targets()</codeph>: An array of all the <codeph>Target</codeph> objects from every <codeph>Result</codeph>in the set.</p></li><li><p><codeph>ok():</codeph> <codeph>Boolean</codeph> that is the same as <codeph>error_nodes.empty</codeph>.</p></li><li><p><codeph>to_data()</codeph>: An array of hashes representing either <codeph>Result</codeph> or <codeph>ApplyResults</codeph>.</p></li></ul><p>A <codeph>Result</codeph> has the following methods:</p><ul><li><p><codeph>value()</codeph>: The hash containing the value of the <codeph>Result</codeph>.</p></li><li><p><codeph>target()</codeph>: The <codeph>Target</codeph> object that the <codeph>Result</codeph> is from.</p></li><li><p><codeph>error()</codeph>: An <codeph>Error</codeph> object constructed from the <codeph>_error</codeph> in the value.</p></li><li><p><codeph>message()</codeph>: The <codeph>_output</codeph> key from the value.</p></li><li><p><codeph>ok()</codeph>: Returns <codeph>true</codeph> if the <codeph>Result</codeph> was successful.</p></li><li><p><codeph>[]</codeph>: Accesses the value hash directly.</p></li><li><p><codeph>to_data()</codeph>: Hash representation of <codeph>Result</codeph>.</p></li><li><p><codeph>action()</codeph>: String representation of result type \(task, command, etc.\).</p></li></ul><p>An <codeph>ApplyResult</codeph> has the following methods:</p><ul><li><p><codeph>report()</codeph>: The hash containing the Puppet report from the application.</p></li><li><p><codeph>target()</codeph>: The <codeph>Target</codeph> object that the <codeph>Result</codeph> is from.</p></li><li><p><codeph>error()</codeph>: An <codeph>Error</codeph> object constructed from the <codeph>_error</codeph> in the value.</p></li><li><p><codeph>ok()</codeph>: Returns <codeph>true</codeph> if the <codeph>Result</codeph> was successful.</p></li><li><p><codeph>to_data()</codeph>: Hash representation of <codeph>ApplyResult</codeph>.</p></li><li><p><codeph>action()</codeph>: String representation of result type \(apply\).</p></li></ul><p>An instance of <codeph>ResultSet</codeph> is <codeph>Iterable</codeph> as if it were an <codeph>Array[Variant[Result, ApplyResult]]</codeph> so that iterative functions such as <codeph>each</codeph>, <codeph>map</codeph>, <codeph>reduce</codeph>, or <codeph>filter</codeph> work directly on the ResultSet returning each result.</p><p>This example checks if a task ran correctly on all nodes. If it did not, the check fails:</p><codeblock xml:space="preserve">$r = run_task('sometask', ..., '_catch_errors' =&gt; true)
unless $r.ok {
  fail("Running sometask failed on the nodes ${r.error_nodes.names}")
}</codeblock><p>You can do iteration and checking if the result is an Error. This example outputs feedback about the result of a task:</p><codeblock xml:space="preserve">$r = run_task('sometask', ..., '_catch_errors' =&gt; true)
$r.each |$result| {
  $node = $result.target.name
  if $result.ok {
    notice("${node} returned a value: ${result.value}")
  } else {
    notice("${node} errored with a message: ${result.error.message}")
  }
}</codeblock><p>Similarly, you can iterate over the array of hashes returned by calling <codeph>to_data</codeph> on a<codeph>ResultSet</codeph> and access hash values. For example:</p><codeblock xml:space="preserve">$r = run_command('whoami', 'localhost,local://0.0.0.0')
$r.to_data.each |$result_hash| { notice($result_hash['result']['stdout']) }</codeblock><p>You can also use <codeph>filter_set</codeph> to filter a <codeph>ResultSet</codeph> and apply a <codeph>ResultSet</codeph> function such as <codeph>targets</codeph> to the output:</p><codeblock xml:space="preserve">$filtered = $result.filter_set |$r| {
  $r['tag'] == "you're it"
}.targets</codeblock></body></topic><topic id="passing-sensitive-data-to-tasks"><title>Passing sensitive data to tasks</title><body><p>Task parameters defined as sensitive are masked when they appear in plans.</p><p>You define a task parameter as sensitive with the metadata property <codeph>"sensitive": true</codeph>. When a task runs, the values for these sensitive parameters are masked.</p><codeblock xml:space="preserve">run_task('task_with_secrets', ..., password =&gt; '$ecret!')</codeblock></body><topic id="working-with-the-sensitive-function"><title>Working with the sensitive function</title><body><p>In Puppet you use the <codeph>Sensitive</codeph> function to mask data in output logs. Because plans are written in Puppet DSL, you can use this type freely. The <codeph>run_task()</codeph> function does not allow parameters of <codeph>Sensitive</codeph> function to be passed. When you need to pass a sensitive value to a task, you must unwrap it prior to calling <codeph>run_task()</codeph>.</p><codeblock xml:space="preserve">$pass = Sensitive('$ecret!')
run_task('task_with_secrets', ..., password =&gt; $pass.unwrap)
</codeblock><p><b>Related information</b></p><p><xref href="writing_tasks.md#" format="dita" type="topic">Adding parameters to metadata</xref></p></body></topic></topic><topic id="target-objects"><title>Target objects</title><body><p>The <codeph>Target</codeph> object represents a node and its specific connection options.</p><p>The state of a target is stored in the inventory for the duration of a plan allowing you to collect facts or set vars for a target and retrieve them later. You can get a printable representation via the <codeph>name</codeph> function, as well as access components of the target: <codeph>protocol, host, port, user, password</codeph>.</p></body><topic id="targetspec"><title>TargetSpec</title><body><p>The execution function takes a parameter with the type alias TargetSpec. This alias accepts the pattern strings allowed by <codeph>--nodes</codeph>, a single Target object, or an Array of Targets and node patterns. Plans that accept a set of targets as a parameter should generally use this type to interact cleanly with the CLI and other plans. To operate on individual nodes, resolve it to a list via <codeph>get_targets</codeph>. For example to loop over each node in a plan accept a <codeph>TargetSpec</codeph> argument but call <codeph>get_targets </codeph>on it before looping.</p><codeblock xml:space="preserve">plan loop(TargetSpec $nodes) {
  get_targets($nodes).each |$target| {
    run_task('my_task', $target)
  }
}</codeblock><p>If your plan accepts a single <codeph>TargetSpec</codeph> parameter you can call that parameter <codeph>nodes</codeph> so that it can be specified with the <codeph>--nodes</codeph> flag from the command line.</p></body></topic><topic id="variables-and-facts-on-targets"><title>Variables and facts on targets</title><body><p>When Bolt runs, it loads transport config values, variables, and facts from the inventory. These can be accessed with the <codeph>$target.facts()</codeph> and <codeph>$target.vars()</codeph> functions. During the course of a plan, you can update the facts or variables for any target. Facts usually come from running <codeph>facter</codeph> or another fact collection application on the target or from a fact store like PuppetDB. Variables are computed externally or assigned directly.</p><p>Set variables in a plan using <codeph>$target.set_var</codeph>:</p><codeblock xml:space="preserve">plan vars(String $host) {
	$target = get_targets($host)[0]
	$target.set_var('newly_provisioned', true)
	$targetvars = $target.vars
	run_command("echo 'Vars for ${host}: ${$targetvars}'", $host)
}
</codeblock><p>Or set variables in the inventory file using the <codeph>vars</codeph> key at the group level.</p><codeblock xml:space="preserve">groups:
  - name: my_nodes
    nodes:
      - localhost
    vars:
      operatingsystem: windows
    config:
      transport: ssh</codeblock></body></topic><topic id="collect-facts-from-the-targets"><title>Collect facts from the targets</title><body><p>The facts plan connects to the target and discovers facts. It then stores these facts on the targets in the inventory for later use.</p><p>The methods used to collect facts:</p><ul><li><p>On <codeph>ssh</codeph> targets, it runs a Bash script.</p></li><li><p>On <codeph>winrm</codeph> targets, it runs a PowerShell script.</p></li><li><p>On <codeph>pcp</codeph> or targets where the Puppet agent is present, it runs Facter.</p></li></ul><p>This example collects facts with the facts plan and then uses those facts to decide which task to run on the targets.</p><codeblock xml:space="preserve">plan run_with_facts(TargetSpec $nodes) {
  # This collects facts on nodes and update the inventory
  run_plan(facts, nodes =&gt; $nodes)

  $centos_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'CentOS' }
  $ubuntu_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'Ubuntu' }
  run_task(centos_task, $centos_nodes)
  run_task(ubuntu_task, $ubuntu_nodes)
}</codeblock></body></topic><topic id="collect-facts-from-puppetdb"><title>Collect facts from PuppetDB</title><body><p>When targets are running a Puppet agent and sending facts to PuppetDB, you can use the <codeph>puppetdb_fact</codeph> plan to collect facts for them. This example collects facts with the <codeph>puppetdb_fact</codeph> plan, and then uses those facts to decide which task to run on the targets. You must configure the PuppetDB client before you run it.</p><codeblock xml:space="preserve">plan run_with_facts(TargetSpec $nodes) {
  # This collects facts on nodes and update the inventory
  run_plan(**puppetdb\_fact**, nodes =&gt; $nodes)

  $centos_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'CentOS' }
  $ubuntu_nodes = get_targets($nodes).filter |$n| { $n.facts['os']['name'] == 'Ubuntu' }
  run_task(centos_task, $centos_nodes)
  run_task(ubuntu_task, $ubuntu_nodes)
}</codeblock><p><b>Related information</b></p><p><xref href="bolt_connect_puppetdb.md" format="dita" type="topic">Connecting Bolt to PuppetDB</xref></p></body></topic></topic><topic id="plan-logging"><title>Plan logging</title><body><p>Set up log files to record certain events that occur when you run plans.</p></body><topic id="puppet-log-functions"><title>Puppet log functions</title><body><p>To generate log messages from a plan, use the Puppet log function that corresponds to the level you want to track: <codeph>error</codeph>, <codeph>warn</codeph>, <codeph>notice</codeph>, <codeph>info</codeph>, or <codeph>debug</codeph>. The default log level for Bolt is <codeph>notice</codeph> but you can set it to <codeph>info</codeph> with the <codeph>--verbose </codeph>flag or <codeph>debug</codeph> with the <codeph>--debug</codeph> flag.</p></body></topic><topic id="default-action-logging"><title>Default action logging</title><body><p>Bolt logs actions that a plan takes on targets through the  <codeph>upload_file</codeph>,  <codeph>run_command</codeph>, <codeph>run_script</codeph>, or <codeph>run_task</codeph>  functions. By default it logs a notice level message when an action starts and another when it completes. If you pass a description to the function, that is used in place of the generic log message.</p><codeblock xml:space="preserve">run_task(my_task, $targets, "Better description", param1 =&gt; "val")</codeblock><p>If your plan contains many small actions you may want to suppress these messages and use explicit calls to the Puppet log functions instead. This can be accomplished by wrapping actions in a <codeph>without_default_logging</codeph> block which causes the action messages to be logged at info level instead of notice. For example to loop over a series of nodes without logging each action.</p><codeblock xml:space="preserve">plan deploy( TargetSpec $nodes) {
  without_default_logging() || {
    get_targets($nodes).each |$node| {
      run_task(deploy, $node)
    }
  }
}
</codeblock><p>To avoid complications with parser ambiguity, always call <codeph>without_default_logging</codeph> with <codeph>()</codeph> and empty block args <codeph>||</codeph>.</p><codeblock xml:space="preserve">without_default_logging() || { run_command('echo hi', $nodes) }</codeblock><p>not</p><codeblock xml:space="preserve">without_default_logging { run_command('echo hi', $nodes) }</codeblock></body></topic><topic id="puppetdb-query"><title>puppetdb\_query</title><body><p>You can use the <codeph>puppetdb_query</codeph> function in plans to make direct queries to PuppetDB. For example you can discover nodes from PuppetDB and then run tasks on them. You'll have to configure the <xref href="bolt_connect_puppetdb.md" format="dita" type="topic">puppetdb client</xref>before running it.</p><codeblock xml:space="preserve">plan pdb_discover {
  $result = puppetdb_query("inventory[certname] { app_role == 'web_server' }")
  # extract the certnames into an array
  $names = $result.map |$r| { $r["certname"] }
  # wrap in url. You can skip this if the default transport is pcp
  $nodes = $names.map |$n| { "pcp://${n}" }
  run_task('my_task', $nodes)
}</codeblock></body></topic></topic><topic id="example-plans"><title>Example plans</title><body><p>Check out some example plans for inspiration writing your own.</p><table><tgroup cols="3"><colspec colname="col1" colnum="1"/><colspec colname="col2" colnum="2"/><colspec colname="col3" colnum="3"/><thead><row><entry colname="col1">Resource</entry><entry colname="col2">Description</entry><entry colname="col3">Level</entry></row></thead><tbody><row><entry colname="col1"><xref href="https://forge.puppet.com/puppetlabs/facts" format="html" scope="external">facts module</xref></entry><entry colname="col2">Contains tasks and plans to discover facts about target systems.</entry><entry colname="col3">Getting started</entry></row><row><entry colname="col1"><xref href="https://github.com/puppetlabs/puppetlabs-facts/blob/master/plans/init.pp" format="pp" scope="external">facts plan</xref></entry><entry colname="col2">Gathers facts using the facts task and sets the facts in inventory.</entry><entry colname="col3">Getting started</entry></row><row><entry colname="col1"><xref href="https://github.com/puppetlabs/puppetlabs-facts/blob/master/plans/info.pp" format="pp" scope="external">facts::info plan</xref></entry><entry colname="col2">Uses the facts task to discover facts and map relevant fact values to targets.</entry><entry colname="col3">Getting started</entry></row><row><entry colname="col1"><xref href="https://forge.puppet.com/puppetlabs/reboot" format="html" scope="external">reboot module</xref></entry><entry colname="col2">Contains tasks and plans for managing system reboots.</entry><entry colname="col3">Intermediate</entry></row><row><entry colname="col1"><xref href="https://github.com/puppetlabs/puppetlabs-reboot/blob/master/plans/init.pp" format="pp" scope="external">reboot plan</xref></entry><entry colname="col2">Restarts a target system and waits for it to become available again.</entry><entry colname="col3">Intermediate</entry></row><row><entry colname="col1"><xref href="https://puppet.com/blog/introducing-masterless-puppet-bolt" format="html" scope="external">Introducing Masterless Puppet with Bolt</xref></entry><entry colname="col2">Blog post explaining how plans can be used to deploy a load-balanced web server.</entry><entry colname="col3">Advanced</entry></row><row><entry colname="col1"><xref href="https://github.com/puppetlabs/bolt/blob/master/docs/11-apply-manifest-code/Boltdir/site/profiles/plans/nginx_install.pp" format="pp" scope="external">profiles::nginx\_install plan</xref></entry><entry colname="col2">Shows an example plan for deploying Nginx and HAProxy.</entry><entry colname="col3">Advanced</entry></row></tbody></tgroup></table><ul><li><p><b>Getting started</b> resources show simple use cases such as running a task and manipulating the results.</p></li><li><p><b>Intermediate</b> resources show more advanced features in the plan language.</p></li><li><p><b>Advanced</b> resources show more complex use cases such as applying puppet code blocks and using external modules.</p></li></ul></body></topic></topic>